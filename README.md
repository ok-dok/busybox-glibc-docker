# A docker base image builder for busybox:glibc

## introduction

This is a docker file repo to build a minimal busybox image with required glibc libraries, which can be used as a base image to build bussiness images.

## Usage

You can add your requires lib, then 'Docker.builder' will search the list of requires lib in /lib/$(gcc -print-multiarch)/, if not exist in, you should modify 'Docker.builder' after line 115 to add it, it should be a list split by line seprator. 

To build and test the image, you should run this command in terminal:

```shell
sh build.sh
```

After build, it will generate two images: "busybox:glibc-builder" and "busybox:glibc".

- busybox:glibc-builder: it is used to compile and generate a compressed file named "busybox.tar.xz".
- busybox:glibc: it is the target image, which based on scratch image and used the "busybox.tar.xz" file generated by "busybox:glibc-builder", and uncompromising the tar file to root path '/'.


# 这是一个构建glibc docker基础镜像的仓库
本仓库是用于构建glibc的最小化busybox基础镜像，大部分源代码来自busybox官方仓库：https://github.com/docker-library/busybox。

busybox:glibc镜像大小约28M。

## 说明
目前，构建的busybox镜像中含有以下类库：

- libnss*.so.*
- libc*.so.*
- libstdc++*.so.*
- libpthread*.so.*
- libgcc_s*.so.*
- libz*.so.*
- libdl*.so.*
- librt*.so.*
- libm*.so.*
- libnuma*.so.*

分别列出在lib.requires.txt文件中，按行分隔，每一行是一个类库的名称，注意：只需要给出类库名称前缀即可，不需要写“\*.so.\*”。

这些类库一般存在于`/user/lib/$(gcc -print-multiarch)/`目录下，然后软连接到目录`/lib/$(gcc -print-multiarch)`，因此，**如果你需要的类库在这个目录下，只需要在lib-requres.txt文件中添加类库名称即可。**

否则，你需要修改Dockerfile.builder文件，添加相关依赖库。具体修改方法见[修改扩展说明](#修改扩展说明)。

## 构建方式
直接在shell终端进入本目录执行脚本命令进行构建：

```shell
sh build.sh
```

执行完成后将会生成两个镜像：
- busybox:glibc-builder： 这是一个用于编译和构建目标镜像busybox:glibc的一个镜像，它将会打包一个名为"busybox.tar.xz"的压缩文件。
- busybox:glibc：这个镜像以scratch为基础镜像，然后将“busybox.tar.xz”压缩文件解压到根目录。

注意：busybox:glibc才是最终用于构建其他业务镜像的基础镜像。busybox:glibc-builder是一个编译环境，是用来编译生成busybox:glibc镜像的。

busybox:glibc-builder是以debian:buster-slim作为基础镜像，通过安装相关类库到环境中，然后拷贝打包制作成最终的压缩文件。

*如果有兴趣，可以研究busybox官方仓库中的说明和源码，以了解整个busybox镜像打包制作的过程。*

## 创建本仓库的动机

由于官方仓库中构建的glibc镜像缺少部分so类库，不太适合直接用来打包C/C++ 程序，尤其是用到一些其他类库，比如zlib、numactl、bzip、ssl时，我们可以很方便的修改Dockerfile.builder，将使用到的类库增加到镜像中，因此我对Dockerfile.builder其中部分逻辑进行了修改，修改的内容区域如下：

```
RUN set -eux; \
	apt-get update; \
	apt-get install -y \
		bzip2 \
		curl \
		gcc \
		gnupg dirmngr \
		make \
		numactl \
		zlib1g \
	; \
	gccMultiarch="$(gcc -print-multiarch)"; \
	ln -vL /usr/lib/$gccMultiarch/*.so.* /lib/$gccMultiarch/; \
	rm -rf /var/lib/apt/lists/*
```
还有另外一部分：

```
	gccMultiarch="$(gcc -print-multiarch)"; \
	requiredLibs=$(cat lib-requires.txt | sed -e 's/[,:;\|\t\r\n ]*//g' | awk '{print "/lib/'"$gccMultiarch"'/"$0"*.so.*"}'); \
	set -- \
		rootfs/bin/busybox \
		rootfs/bin/getconf \
		/lib/"$gccMultiarch"/libnss*.so.* \
# needed libs of glibc, such as libc, libthread and others: https://stackoverflow.com/a/11210463/433558
		$requiredLibs \
    ; \
```
**说明：**

```shell
requiredLibs=$(cat lib-requires.txt | sed -e 's/[,:;\|\t\r\n ]*//g' | awk '{print "/lib/'"$gccMultiarch"'/"$0"*.so.*"}');
```

这行命令用来获取lib-requires.txt中列出的类库名称，并保存在变量$requiredLibs中。

`set -- args`命令的作用是：在当前执行上下文中，将`--`后面的`args`参数依次设置到当前的作用域中，后续就可以使用\$0,\$1,\$2...$#来获取这些参数。

在这部分代码之后，有一个循环遍历操作：

```
    while [ "$#" -gt 0 ]; do \
		f="$1"; shift; \
		fn="$(basename "$f")"; \
		if [ -e "rootfs/lib/$fn" ]; then continue; fi; \
		if [ "${f#rootfs/}" = "$f" ]; then \
			if [ "${fn#ld-}" = "$fn" ]; then \
				ln -vL "$f" "rootfs/lib/$fn"; \
			else \
				cp -v "$f" "rootfs/lib/$fn"; \
			fi; \
		fi; \
		ldd="$(ldd "$f" | awk ' \
			$1 ~ /^\// { print $1; next } \
			$2 == "=>" && $3 ~ /^\// { print $3; next } \
		')"; \
		set -- "$@" $ldd; \
	done;
```

目的很简单，就是依次取出上面设置的参数（即列出的类库名称），然后将其软连接或者拷贝到`rootfs/lib`目录下，并挂载到动态链接库`ldd.so`。


## 修改扩展说明

在了解到上述的说明之后，如果想要添加额外的依赖库，就很容易了，分为两种情况：

1. 要添加的类库在`/lib/$gccMultiarch`目录下
2. 要添加的类库在其他目录下

对于第一种情况，就比较简单，只需要在`lib-requires.txt`中列出需要依赖的库的basename即可。

对于第二种情况，一种比较简单的处理办法是：

找到对应的类库位置，将其通过软连接连接到`/lib/$gccMultiarch`目录下，在Dockerfile.builder中添加`RUN`命令，添加软连接命令就可以，然后在`lib-requires.txt`文件中添加这个类库名称。

或者，你也可以直接在`Dockerfile.builder`中修改，在第115行之后，直接添加该类库的位置，形如：

```shell
/user/local/lib/xxx*.so.*
```

最后执行`sh build.sh`编译构建。

## 如何确定自己需要的依赖库在哪个目录下？

你可以使用镜像busybox:glibc-builder来启动一个容器：

```shell
docker run -it --rm busybox:glibc-builder /bin/bash
```

在交互模式的shell终端中，进行下载安装类库，比如你可以使用`apt-get`命令进行安装，也可以使用`wget`命令下载`dpkg`安装包，再使用`dpkg -i [pkg]`来进行安装，或者，直接下载源代码编译安装。

安装完成后不知道相关类库在哪里？

```
whereis xxx
```

这个命令可以帮你查找相关类库存在的位置，或者使用find命令来查找。

一旦在这个容器中调试ok，那么就可以回来修改`Dockerfile.builder`构建脚本了。

1. 第一步，在一开始的`RUN`命令中的`apt-get install -y`后面的列表中添加你需要安装的依赖库，或者重新写一条`RUN`命令来安装相关依赖。
2. 第二步，就是添加依赖包的软连接到`/lib/$gccMultiarch/`
3. 第三步，在lib-requires.txt添加类库名称

其中，二、三步可以直接合并为一步，在115行后面添加依赖库的位置。
